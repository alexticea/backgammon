<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Backgammon - Single Player</title>
    <!-- Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="root">
        <div class="loading">Loading...</div>
    </div>
    <script type="text/babel">
        // --- CONSTANTS ---
        const PLAYER_HUMAN = 1;  // White (Moves 23 -> 0)
        const PLAYER_AI = -1;    // Red (Moves 0 -> 23)
        const BAR_HUMAN = 25;    // Conceptual index
        const BAR_AI = 26;       // Conceptual index

        // --- HELPERS ---
        const { useState, useEffect, useRef } = React;

        function App() {
            // --- STATE ---
            const [wallet, setWallet] = useState(null);
            const [balance, setBalance] = useState(0);

            // Board: 0-23 are standard points.
            // visual layout will handle mapping.
            // Start Setup:
            // Human (White) starts at 23 (2 checkers), 12 (5), 7 (3), 5 (5)
            // AI (Red) starts at 0 (2 checkers), 11 (5), 16 (3), 18 (5)

            const initialBoard = Array(24).fill(null).map(() => ({ count: 0, player: 0 }));
            const place = (idx, count, player) => { initialBoard[idx] = { count, player }; };

            place(23, 2, PLAYER_HUMAN);
            place(12, 5, PLAYER_HUMAN);
            place(7, 3, PLAYER_HUMAN);
            place(5, 5, PLAYER_HUMAN);

            place(0, 2, PLAYER_AI);
            place(11, 5, PLAYER_AI);
            place(16, 3, PLAYER_AI);
            place(18, 5, PLAYER_AI);

            const [board, setBoard] = useState(initialBoard);
            const [bar, setBar] = useState({ [PLAYER_HUMAN]: 0, [PLAYER_AI]: 0 });
            const [off, setOff] = useState({ [PLAYER_HUMAN]: 0, [PLAYER_AI]: 0 });

            const [dice, setDice] = useState([]);
            const [visualDice, setVisualDice] = useState([]);
            const [turn, setTurn] = useState(null);
            const [difficulty, setDifficulty] = useState('beginner');
            const [isDropdownOpen, setIsDropdownOpen] = useState(false); // For menu
            const [logs, setLogs] = useState(["Welcome to Solana Backgammon!"]);
            const [selectedPoint, setSelectedPoint] = useState(null);
            const [validMoves, setValidMoves] = useState([]);
            const [rolling, setRolling] = useState(false);
            const [canRoll, setCanRoll] = useState(false);
            const [history, setHistory] = useState([]); // Array of states for undo within turn
            const [gameStatus, setGameStatus] = useState('menu'); // menu, playing, gameover
            const [gameMode, setGameMode] = useState('single'); // 'single' or 'multi'
            const [playerColor, setPlayerColor] = useState(PLAYER_HUMAN); // In multi: assigned by server
            const [roomId, setRoomId] = useState(null);
            const [opponentName, setOpponentName] = useState('AI');
            const [opponentWallet, setOpponentWallet] = useState(null);
            const [opponentLevel, setOpponentLevel] = useState(1);
            const [socket, setSocket] = useState(null);
            const [finishingTurn, setFinishingTurn] = useState(false);
            const [isBlocked, setIsBlocked] = useState(false);
            const [escrowBalance, setEscrowBalance] = useState(0.00);

            // --- REFS FOR SOCKET HANDLERS ---
            const gameStatusRef = useRef(gameStatus);

            useEffect(() => { gameStatusRef.current = gameStatus; }, [gameStatus]);

            const selectedStakeRef = useRef(selectedStake);
            useEffect(() => { selectedStakeRef.current = selectedStake; }, [selectedStake]);

            const escrowBalanceRef = useRef(escrowBalance);
            useEffect(() => { escrowBalanceRef.current = escrowBalance; }, [escrowBalance]);

            // --- SOCKET INIT ---
            useEffect(() => {
                // Determine Server URL: Local vs Production
                const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                // For Vercel deployment, you will replace the second string with your Render/Railway backend URL.
                const SERVER_URL = isLocal ? 'http://localhost:3001' : 'https://backgammon-usxq.onrender.com';

                const newSocket = io(SERVER_URL);
                setSocket(newSocket);

                newSocket.on('connect', () => {
                    console.log("Connected to Game Server:", newSocket.id);
                    setLogs(prev => ["Connected to Server!", ...prev]); // Visual Confirm
                });

                newSocket.on('connect_error', (err) => {
                    console.error("Connection Error:", err);
                    setLogs(prev => ["Connection Failed! Check Server URL.", ...prev]);
                });

                newSocket.on('waiting_for_match', () => {
                    setLogs(prev => ["Waiting for an opponent...", ...prev]);
                });

                newSocket.on('match_found', (data) => {
                    console.log("Match Found!", data);
                    setRoomId(data.roomId);
                    setIsSearching(false);
                    // Identify Opponent Name
                    const oppId = Object.keys(data.players).find(id => id !== newSocket.id);
                    const oppName = data.players[oppId]?.name || "Opponent";
                    setOpponentName(oppName);
                    setOpponentWallet(data.players[oppId]?.wallet || null);

                    alert(`Match Found! Playing against ${oppName}`);
                });

                newSocket.on('assign_color', (colorStr) => {
                    const myColor = colorStr === 'white' ? PLAYER_HUMAN : PLAYER_AI;
                    setPlayerColor(myColor);
                    console.log("Assigned Color:", colorStr, myColor);

                    // Start Game Logic
                    const stake = selectedStakeRef.current;
                    if (stake && stake > 0) {
                        const balance = escrowBalanceRef.current || 0;
                        if (balance >= stake) {
                            // Deduct Stake
                            setEscrowBalance(prev => parseFloat((prev - stake).toFixed(2)));
                            log(`Staked ${stake} SOL from Escrow Balance.`);

                            // Start Game
                            setGameMode('multi');
                            setGameStatus('opening_roll');
                            setOpeningRoll(null);
                            setRolling(false);
                            setTurn('human');
                            log("Match Found! Roll for the first turn.");
                        } else {
                            alert(`Insufficient Escrow Balance! You need ${stake} SOL. Please deposit.`);
                            setGameStatus('multiplayer_menu');
                            // Ideally emit 'leave_match' here
                            return;
                        }
                    } else {
                        // Free Play
                        setGameMode('multi');
                        setGameStatus('opening_roll');
                        setOpeningRoll(null);
                        setRolling(false);
                        setTurn('human');
                        log("Match Found! Roll for the first turn.");
                    }

                });

                // REMOVED: newSocket.on('game_start') - Logic moved to match_found direct check

                newSocket.on('game_update', ({ type, payload }) => {
                    handleRemoteEvent(type, payload);
                });

                newSocket.on('chat_message', (msg) => {
                    setChatMessages(prev => [...prev, { ...msg, type: 'opponent' }]);
                });

                newSocket.on('withdraw_success', ({ amount, signature }) => {
                    log(`Withdrawal of ${amount} SOL sent! Sig: ${signature.slice(0, 8)}...`);
                    alert(`Funds sent to your wallet!`);
                    setEscrowBalance(prev => parseFloat((prev - amount).toFixed(2)));
                });

                newSocket.on('withdraw_error', (msg) => {
                    alert("Withdrawal Failed: " + msg);
                });

                return () => newSocket.close();
            }, []);

            const handleRemoteEvent = (type, payload) => {
                const currentStatus = gameStatusRef.current;

                if (type === 'roll') {
                    // Robustness check: Ensure we handle Opening Roll vs Game Roll correctly
                    // Opening Roll = 1 die. Game Roll = 2 dice (or 4).
                    if (currentStatus === 'opening_roll' && payload.length === 1) {
                        // Handle Opponent Opening Roll
                        const val = payload[0]; // sent as array [val] or just val? Let's assume array for consistency with 'roll'
                        log(`Opponent Rolled: ${val} (Opening)`);
                        setOpeningRoll(prev => {
                            const newState = { ...prev, ai: val };
                            checkMultiOpeningWinner(newState);
                            return newState;
                        });
                    } else {
                        log(`Opponent Rolled: ${payload.join(', ')}`);
                        // Visual only - show max 2 dice even for doubles
                        setVisualDice(payload.slice(0, 2));
                        setDice(payload);
                    }
                } else if (type === 'state_update') {
                    // Full state sync from opponent (Undo, Move, etc)
                    if (payload.board) setBoard(payload.board);
                    if (payload.bar) setBar(payload.bar);
                    if (payload.off) setOff(payload.off);
                    if (payload.dice) {
                        setDice(payload.dice);
                        // Update visuals to match logic
                        setVisualDice(payload.dice);
                    }
                } else if (type === 'move') {
                    // Legacy/Simple move handler (keep for backward compat or just use state_update)
                    if (payload.board) {
                        setBoard(payload.board);
                        setBar(payload.bar);
                    }
                } else if (type === 'end_turn') {
                    log("Opponent finished turn.");
                    setTurn('human');
                    setCanRoll(true);
                } else if (type === 'resign') {
                    setGameStatus('gameover');
                    setGameResult('win');
                    log("Opponent Resigned! You Win!");
                    playDiceSound();
                    updateStats('win');
                }
            };

            const emitGameEvent = (type, payload) => {
                if (socket && roomId) {
                    socket.emit('game_event', { roomId, type, payload });
                }
            };

            // --- PROFILE LOGIC ---
            const [userProfile, setUserProfile] = useState({ name: '', avatar: null });
            const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);
            const [isWalletSelectorOpen, setIsWalletSelectorOpen] = useState(false); // Mobile Wallet Selector

            // --- TIMER LOGIC ---
            const [turnTimer, setTurnTimer] = useState(180); // 3 minutes per turn

            useEffect(() => {
                let interval = null;
                // Only count down if it is literally OUR turn (human)
                if (gameStatus === 'playing' && turn === 'human') {
                    interval = setInterval(() => {
                        setTurnTimer((prev) => {
                            if (prev <= 1) {
                                clearInterval(interval);
                                handleForfeit();
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);
                } else {
                    setTurnTimer(180); // Reset timer on undo
                    // Clear blocked state if we undo
                    setIsBlocked(false);
                }
                return () => clearInterval(interval);
            }, [turn, gameStatus]);

            const handleForfeit = () => {
                if (gameMode === 'multi') {
                    emitGameEvent('resign', {});
                }
                setGameStatus('gameover');
                setGameResult('loss');
                log("You resigned.");
                updateStats('loss');
            };

            useEffect(() => {
                if (wallet && !wallet.startsWith('Guest')) {
                    const saved = localStorage.getItem('bg_profile_' + wallet);
                    if (saved) {
                        try {
                            const parsed = JSON.parse(saved);
                            // Merge with default stats if missing
                            if (!parsed.stats) parsed.stats = { wins: 0, losses: 0, xp: 0, level: 1 };
                            setUserProfile(parsed);
                        } catch (e) { console.error(e); }
                    } else {
                        setUserProfile({ name: '', avatar: null, stats: { wins: 0, losses: 0, xp: 0, level: 1 } });
                    }

                    // LOAD ESCROW BALANCE
                    const savedBalance = localStorage.getItem('escrow_balance_' + wallet);
                    if (savedBalance) {
                        setEscrowBalance(parseFloat(savedBalance));
                    } else {
                        setEscrowBalance(0.00);
                    }

                } else if (wallet && wallet.startsWith('Guest')) {
                    setUserProfile({ name: 'Guest', avatar: null, stats: { wins: 0, losses: 0, xp: 0, level: 1 } });
                    setEscrowBalance(0.00);
                }
            }, [wallet]);

            // Persist Escrow Balance
            useEffect(() => {
                if (wallet && !wallet.startsWith('Guest')) {
                    localStorage.setItem('escrow_balance_' + wallet, escrowBalance.toString());
                }
            }, [escrowBalance, wallet]);

            const updateStats = (result) => {
                if (!wallet || wallet.startsWith('Guest')) return; // Guests don't save stats

                setUserProfile(prev => {
                    const newStats = { ...prev.stats };
                    if (result === 'win') {
                        newStats.wins += 1;
                        newStats.xp += 100;
                    } else {
                        newStats.losses += 1;
                        newStats.xp += 20; // Consolation XP
                    }
                    newStats.level = Math.floor(newStats.xp / 500) + 1;

                    const newProfile = { ...prev, stats: newStats };
                    localStorage.setItem('bg_profile_' + wallet, JSON.stringify(newProfile));
                    return newProfile;
                });
            };

            const handleSaveProfile = (name, avatarBase64) => {
                const newProfile = { name, avatar: avatarBase64 };
                setUserProfile(newProfile);
                if (wallet && !wallet.startsWith('Guest')) {
                    try {
                        localStorage.setItem('bg_profile_' + wallet, JSON.stringify(newProfile));
                    } catch (e) {
                        alert("Image too large! Use a smaller image.");
                    }
                }
                setIsProfileModalOpen(false);
            };

            // --- CHAT LOGIC ---
            const [chatMessages, setChatMessages] = useState([{ sender: 'System', text: 'Welcome to the chat!' }]);
            const [chatInput, setChatInput] = useState('');
            const [gameResult, setGameResult] = useState(null); // 'win' or 'loss'
            const [depositTx, setDepositTx] = useState(null);

            const handleDeposit = async () => {
                if (!selectedStake) return;

                try {
                    // MOCK ESCROW / HOUSE WALLET (In real app, simpler to use a PDA)
                    const ESCROW_PUBKEY = "Escrow7123981239812398123981239812398123";

                    // Native Transfer Logic
                    const connection = new window.solanaWeb3.Connection(window.solanaWeb3.clusterApiUrl('devnet'));
                    const transaction = new window.solanaWeb3.Transaction().add(
                        window.solanaWeb3.SystemProgram.transfer({
                            fromPubkey: new window.solanaWeb3.PublicKey(wallet),
                            toPubkey: new window.solanaWeb3.PublicKey("6cgsK8ph5tNUCiKG5WXLMZFX1CoL4jzuVouTPBwPC8fk"), // House Escrow
                            lamports: selectedStake * 1000000000,
                        })
                    );

                    transaction.feePayer = new window.solanaWeb3.PublicKey(wallet);
                    const { blockhash } = await connection.getLatestBlockhash();
                    transaction.recentBlockhash = blockhash;

                    // Provider Sign
                    let provider = window.solflare || window.solana;
                    if (!provider) throw new Error("No Wallet");

                    const { signature } = await provider.signAndSendTransaction(transaction);
                    log("Deposit Sent! Sig: " + signature.slice(0, 8) + "...");
                    setDepositTx(signature);

                    // Notify Server
                    if (socket && roomId) {
                        socket.emit('deposit_stake', { roomId, signature });
                    }

                } catch (err) {
                    console.error("Deposit Failed", err);
                    alert("Deposit Failed: " + err.message);
                }
            };

            const fetchBalance = async () => {
                if (!wallet || wallet.startsWith('Guest')) return;
                try {
                    const connection = new window.solanaWeb3.Connection(window.solanaWeb3.clusterApiUrl('devnet'));
                    const lamports = await connection.getBalance(new window.solanaWeb3.PublicKey(wallet));
                    setBalance((lamports / 1000000000).toFixed(2));
                } catch (e) { console.error(e); }
            };

            const handleEscrowDeposit = async () => {
                const amountStr = prompt("Enter annual amount to deposit (SOL):", "0.1");
                if (!amountStr) return;
                const amount = parseFloat(amountStr);
                if (isNaN(amount) || amount <= 0) return;

                // TX Logic (Reuse handleDeposit logic logic practically)
                // For MVP, emulate success
                try {
                    // In real app: Send TX
                    // setEscrowBalance(prev => prev + amount);
                    // alert("Deposited to Escrow!");

                    // Let's use real simple TX for "Real Feel"
                    if (!wallet) return alert("Connect Wallet first");
                    const connection = new window.solanaWeb3.Connection(window.solanaWeb3.clusterApiUrl('devnet'));
                    const transaction = new window.solanaWeb3.Transaction().add(
                        window.solanaWeb3.SystemProgram.transfer({
                            fromPubkey: new window.solanaWeb3.PublicKey(wallet),
                            toPubkey: new window.solanaWeb3.PublicKey("6cgsK8ph5tNUCiKG5WXLMZFX1CoL4jzuVouTPBwPC8fk"), // House Escrow
                            lamports: amount * 1000000000,
                        })
                    );
                    transaction.feePayer = new window.solanaWeb3.PublicKey(wallet);
                    const { blockhash } = await connection.getLatestBlockhash();
                    transaction.recentBlockhash = blockhash;
                    const provider = window.solflare || window.solana;
                    const { signature } = await provider.signAndSendTransaction(transaction);

                    log("Escrow Deposit: " + amount + " SOL");
                    setEscrowBalance(prev => parseFloat((prev + amount).toFixed(2)));
                    setTimeout(fetchBalance, 2000); // Trigger Wallet Refresh

                } catch (e) {
                    alert("Deposit Error: " + e.message);
                }
            };

            const handleEscrowWithdraw = () => {
                const amountStr = prompt("Enter amount to withdraw (SOL):", "0.1");
                if (!amountStr) return;
                const amount = parseFloat(amountStr);
                if (escrowBalance < amount) return alert("Insufficient Escrow Balance");

                // REAL ARCHITECTURE: Request Server to Sign
                log("Requesting Withdrawal...");
                if (socket) {
                    // The backend must hold the Private Key for the Escrow Wallet
                    socket.emit('request_withdraw', { wallet, amount });
                } else {
                    alert("Not connected to server.");
                }
            };

            const handleChatSend = () => {
                if (!chatInput.trim()) return;
                const newMsg = { sender: 'You', text: chatInput, type: 'user' };
                setChatMessages(prev => [...prev, newMsg]);

                if (gameMode === 'multi' && socket && roomId) {
                    socket.emit('chat_message', { roomId, message: chatInput, sender: userProfile.name || "Opponent" });
                }

                setChatInput('');

                if (gameMode === 'single') {
                    // Bot Auto-Response Simulation
                    setTimeout(() => {
                        const responses = ["Interesting move!", "Good luck!", "I'm thinking...", "Nice try!", "Focus on the game!"];
                        const reply = { sender: 'Bot', text: responses[Math.floor(Math.random() * responses.length)], type: 'bot' };
                        setChatMessages(prev => [...prev, reply]);
                    }, 1500);
                }
            };

            // --- MULTIPLAYER LOGIC ---
            const [isSearching, setIsSearching] = useState(false);
            const [selectedStake, setSelectedStake] = useState(null); // null = free, number = SOL

            const handleSearchMatch = (stake) => {
                if (!wallet || wallet.startsWith('Guest')) {
                    alert("You must connect a real wallet to play Multiplayer!");
                    return;
                }
                setSelectedStake(stake);
                setIsSearching(true);

                // REAL SOCKET MATCHMAKING
                if (socket) {
                    // Use Wallet short address if name is empty
                    const displayName = userProfile.name && userProfile.name.trim() !== ''
                        ? userProfile.name
                        : `${wallet.slice(0, 4)}...${wallet.slice(-4)}`;

                    socket.emit('find_match', {
                        name: displayName,
                        wallet: wallet,
                        level: userProfile.stats ? userProfile.stats.level : 1
                    });
                } else {
                    alert("Server connection failed. Retrying...");
                    // Retry connect
                    const newSocket = io('http://localhost:3001');
                    setSocket(newSocket);
                }
            };

            // --- LEADERBOARD ---
            const getLeaderboard = () => {
                const players = [];
                // 1. Local Profiles
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('bg_profile_')) {
                        try {
                            const p = JSON.parse(localStorage.getItem(key));
                            if (p.stats) players.push(p);
                        } catch (e) { }
                    }
                }
                // 2. Mock Global Players (to fill Top 20)
                const mockPlayers = [
                    { name: 'SolanaKing', stats: { level: 50, wins: 402, xp: 25000 }, avatar: null },
                    { name: 'BackgammonPro', stats: { level: 42, wins: 310, xp: 21000 }, avatar: null },
                    { name: 'CryptoWhale', stats: { level: 35, wins: 205, xp: 17500 }, avatar: null },
                    { name: 'LuckyDice', stats: { level: 28, wins: 150, xp: 14000 }, avatar: null },
                    { name: 'DevNet_User', stats: { level: 10, wins: 45, xp: 5000 }, avatar: null },
                    { name: 'BearMarket', stats: { level: 8, wins: 33, xp: 4000 }, avatar: null },
                    { name: 'BullRun', stats: { level: 5, wins: 20, xp: 2500 }, avatar: null },
                    { name: 'HODLer', stats: { level: 15, wins: 60, xp: 7500 }, avatar: null },
                ];

                // Merge and Sort
                const all = [...players, ...mockPlayers];
                // Deduplicate by name (simple check)
                const unique = Array.from(new Map(all.map(item => [item.name, item])).values());

                return unique.sort((a, b) => (b.stats.level || 0) - (a.stats.level || 0)).slice(0, 20);
            };

            // --- WALLET ---
            const connectWallet = async () => {
                // 1. Prioritize window.solflare (Explicit Solflare User)
                let provider = window.solflare;

                // 2. Fallback to window.solana (Phantom / Mobile / Other)
                if (!provider && window.solana) {
                    provider = window.solana;
                }

                if (!provider) {
                    // Show Selector Modal for ALL users (Mobile/Seeker/Desktop without extension)
                    setIsWalletSelectorOpen(true);
                    return;
                }

                try {
                    const resp = await provider.connect();
                    // Some wallets return { publicKey }, others set provider.publicKey
                    let pubKey = resp.publicKey || provider.publicKey;
                    pubKey = pubKey.toString();

                    // --- SIGN IN WITH SOLANA (SIWS) ---
                    try {
                        // 1. Create Login Message
                        const nonce = "nonce_" + Date.now();
                        const date = new Date().toISOString();
                        const message = `Sign in to MyApp\n\nWallet: ${pubKey}\nNonce: ${nonce}\nIssued At: ${date}`;

                        // 2. Request Signature
                        const encodedMessage = new TextEncoder().encode(message);
                        let signature;

                        if (provider.signMessage) {
                            // Solflare and others expect just the message (Uint8Array)
                            // Passing "utf8" as second arg can cause issues in some versions
                            const signed = await provider.signMessage(encodedMessage);
                            signature = signed.signature || signed; // Unify response
                        } else {
                            console.warn("Wallet does not support signMessage");
                            alert("Wallet signing not supported (Seed Vault may be read-only here). Logging in as read-only.");
                        }

                        // 3. Authenticate
                        setWallet(pubKey);

                        // Load Profile Logic
                        const existing = localStorage.getItem('bg_profile_' + pubKey);
                        let profileData;
                        if (existing) {
                            try {
                                profileData = JSON.parse(existing);
                            } catch (e) {
                                profileData = { name: '', avatar: null, stats: { level: 1, wins: 0, losses: 0, xp: 0 } };
                            }
                        } else {
                            profileData = { name: '', avatar: null, stats: { level: 1, wins: 0, losses: 0, xp: 0 } };
                        }

                        // Check for Seeker .skr Name or typical wallet name
                        const candidateName = resp.name || resp.label || resp.domain || resp.id;
                        if (candidateName && typeof candidateName === 'string' && candidateName.endsWith('.skr')) {
                            profileData.name = candidateName;
                        }

                        setUserProfile(profileData);

                        // Fetch Real Balance (Devnet)
                        try {
                            const connection = new window.solanaWeb3.Connection(
                                window.solanaWeb3.clusterApiUrl('devnet'),
                                'confirmed'
                            );
                            const lamports = await connection.getBalance(new window.solanaWeb3.PublicKey(pubKey));
                            setBalance((lamports / 1000000000).toFixed(2));
                        } catch (e) {
                            // Ignore
                            setBalance("0.00");
                        }

                    } catch (signErr) {
                        console.error("Sign-In Failed/Rejected", signErr);
                        alert("Sign-In failed or was rejected. You must sign the message to log in.");
                        return; // Do not log in
                    }

                } catch (err) {
                    console.error("Connection cancelled:", err);
                    alert("Wallet connection failed or cancelled: " + (err.message || err));
                }
            };

            const handleGuestLogin = () => {
                const guestId = Math.floor(Math.random() * 9000) + 1000;
                setWallet(`Guest#${guestId}`);
                setBalance("1000 PLAY"); // Demo currrency
                log("Logged in as Guest.");
            };

            const log = (msg) => {
                setLogs(prev => [msg, ...prev.slice(0, 4)]);
            };

            const [openingRoll, setOpeningRoll] = useState(null); // { human: 0, ai: 0 }

            const startGame = (diff) => {
                setDifficulty(diff || 'advanced');
                setGameMode('single'); // Explictly set single player
                setBoard(initialBoard);
                setBar({ [PLAYER_HUMAN]: 0, [PLAYER_AI]: 0 });
                setOff({ [PLAYER_HUMAN]: 0, [PLAYER_AI]: 0 });
                setDice([]);
                setVisualDice([]);
                setValidMoves([]);
                setSelectedPoint(null);
                setHistory([]);
                setGameResult(null);
                setOpeningRoll(null);
                setGameStatus('opening_roll');
                log(`Game Started! Difficulty: ${diff}`);
                log("Rolling for first turn...");
            };

            const handleOpeningRoll = () => {
                playDiceSound();
                setRolling(true);

                // MULTIPLAYER LOGIC
                if (gameMode === 'multi') {
                    setTimeout(() => {
                        const hDie = Math.ceil(Math.random() * 6);

                        // Update Local State
                        setOpeningRoll(prev => {
                            const newState = { ...(prev || {}), human: hDie };
                            checkMultiOpeningWinner(newState);
                            return newState;
                        });
                        setRolling(false);
                        log(`You Rolled: ${hDie} (Opening)`);

                        // Emit to Opponent
                        // We reuse standard 'roll' event but context is opening_roll
                        emitGameEvent('roll', [hDie]);

                    }, 600);
                    return;
                }

                // SINGLE PLAYER LOGIC

                setTimeout(() => {
                    const hDie = Math.ceil(Math.random() * 6);
                    const aDie = Math.ceil(Math.random() * 6);
                    setOpeningRoll({ human: hDie, ai: aDie });
                    setRolling(false);

                    if (hDie > aDie) {
                        log(`You rolled ${hDie}, AI rolled ${aDie}. You start!`);
                        setTurn('human');
                        setDice([]); // Reset for re-roll
                        setVisualDice([]);
                        setCanRoll(true); // Winner rolls again
                        setTimeout(() => setGameStatus('playing'), 1500);
                    } else if (aDie > hDie) {
                        log(`You rolled ${hDie}, AI rolled ${aDie}. AI starts!`);
                        setTurn('ai');
                        setDice([]); // Reset for re-roll
                        setVisualDice([]);
                        setTimeout(() => {
                            setGameStatus('playing');
                            // Trigger AI Logic
                        }, 1500);
                    } else {
                        log(`Tie (${hDie}-${aDie})! Rerolling...`);
                        setTimeout(handleOpeningRoll, 1000);
                    }
                }, 600);
            };

            const checkMultiOpeningWinner = (rolls) => {
                if (rolls && rolls.human && rolls.ai) {
                    setTimeout(() => {
                        const h = rolls.human;
                        const a = rolls.ai;

                        if (h > a) {
                            log(`You won opening roll (${h} vs ${a})! You start.`);
                            setTurn('human');
                            setDice([]); // Winner rolls again
                            setVisualDice([]);
                            setCanRoll(true);
                            setGameStatus('playing');
                            setOpeningRoll(null);
                        } else if (a > h) {
                            log(`Opponent won opening roll (${a} vs ${h}). Opponent starts.`);
                            setTurn('opponent');
                            setDice([]); // Wait for opponent re-roll
                            setVisualDice([]);
                            setGameStatus('playing');
                            setOpeningRoll(null);
                        } else {
                            log(`Tie (${h}-${a})! Re-rolling...`);
                            setTimeout(() => {
                                setOpeningRoll(null);
                                log("Click Roll to try again.");
                            }, 1500);
                        }
                    }, 1000);
                }
            };

            const handleManualRoll = () => {
                if (!canRoll || rolling || turn !== 'human') return;
                performRoll((d) => {
                    log(`You Rolled: ${d.join(', ')}`);
                    setCanRoll(false);
                    // Snapshot state after roll
                    setHistory([]);
                    setIsBlocked(false); // Reset blocked state on new roll

                    if (gameMode === 'multi') {
                        emitGameEvent('roll', d);
                    }
                });
            };

            const handleUndo = () => {
                if (history.length === 0 || finishingTurn) return;
                const lastState = history[history.length - 1];
                setBoard(lastState.board);
                setBar(lastState.bar);
                setDice(lastState.dice);
                setTurn(lastState.turn);
                // Don't restore canRoll usually, as we undoing moves after roll.
                setIsBlocked(false); // Undo should always unblock

                setHistory(prev => prev.slice(0, -1));
                setValidMoves([]);
                setSelectedPoint(null);
                log("Undo last move.");

                // MULTIPLAYER SYNC
                if (gameMode === 'multi') {
                    emitGameEvent('state_update', {
                        board: lastState.board,
                        bar: lastState.bar,
                        dice: lastState.dice
                    });
                }
            };

            // --- GAME LOGIC ---

            const playMoveSound = () => {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) return;

                    const ctx = new AudioContext();
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    // Simulate a wooden click/tap
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(500, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);

                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                    osc.connect(gain);
                    gain.connect(ctx.destination);

                    osc.start();
                    osc.stop(ctx.currentTime + 0.1);
                } catch (e) { }
            };

            const playDiceSound = () => {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) return;

                    const ctx = new AudioContext();
                    const t = ctx.currentTime;

                    // Create two "hits" to simulate dice rattling/landing
                    [0, 0.1].forEach(offset => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();

                        osc.type = 'triangle'; // Wood-like sound
                        osc.frequency.setValueAtTime(150 + Math.random() * 50, t + offset);
                        osc.frequency.exponentialRampToValueAtTime(40, t + offset + 0.1);

                        gain.gain.setValueAtTime(0.5, t + offset);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + offset + 0.1);

                        osc.connect(gain);
                        gain.connect(ctx.destination);

                        osc.start(t + offset);
                        osc.stop(t + offset + 0.1);
                    });
                } catch (e) {
                    console.error("Sound Synth Error", e);
                }
            };

            const performRoll = (cb) => {
                playDiceSound();

                setRolling(true);
                setDice([]);
                setVisualDice([]);

                setTimeout(() => {
                    let roll = [Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)];
                    setVisualDice(roll);

                    // Handle Doubles (x4 Moves, but keep 2 Visual Dice)
                    let functionalDice = [...roll];
                    if (roll[0] === roll[1]) {
                        log(`Doubles! ${roll[0]}-${roll[0]} (4 Moves)`);
                        functionalDice = [roll[0], roll[0], roll[0], roll[0]];
                    }

                    setDice(functionalDice);
                    setRolling(false);
                    if (cb) cb(functionalDice);
                }, 800);
            };

            const rollDice = () => {
                return [Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)];
            };



            const handlePassTurn = () => {
                setDice([]);
                setIsBlocked(false);
                setFinishingTurn(true);
                setTimeout(() => {
                    setFinishingTurn(false);
                    if (gameMode === 'multi') {
                        log("Turn Finished. Waiting for opponent...");
                        setTurn('opponent');
                        emitGameEvent('end_turn', {});
                    } else {
                        log("Turn Finished. AI Moving...");
                        setTurn('ai');
                    }
                }, 2000);
            };

            // CHECK HUMAN MOVES LOGIC
            const checkHumanCanMove = (currentBoard, currentBar, currentDice) => {
                if (currentDice.length === 0) return true; // Handled elsewhere

                const uniqueDice = [...new Set(currentDice)];
                const opponent = playerColor === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN;
                const direction = playerColor === PLAYER_HUMAN ? -1 : 1;

                // 1. Check Bar
                if (currentBar[playerColor] > 0) {
                    return uniqueDice.some(d => {
                        // White (1): 24-d. Red (-1): d-1
                        const target = playerColor === PLAYER_HUMAN ? 24 - d : d - 1;
                        if (target >= 0 && target <= 23) {
                            const dest = currentBoard[target];
                            return !(dest.player === opponent && dest.count > 1);
                        }
                        return false;
                    });
                }

                // 2. Check Board
                let canBearOff = true;
                if (currentBar[playerColor] > 0) canBearOff = false;
                else {
                    // White: 6-23. Red: 0-17.
                    const start = playerColor === PLAYER_HUMAN ? 6 : 0;
                    const end = playerColor === PLAYER_HUMAN ? 23 : 17;
                    for (let i = start; i <= end; i++) {
                        if (currentBoard[i].player === playerColor && currentBoard[i].count > 0) {
                            canBearOff = false;
                            break;
                        }
                    }
                }

                for (let i = 0; i < 24; i++) {
                    if (currentBoard[i].player === playerColor && currentBoard[i].count > 0) {
                        for (let d of uniqueDice) {
                            const target = i + (d * direction);
                            // Normal Move
                            if (target >= 0 && target <= 23) {
                                const dest = currentBoard[target];
                                if (!(dest.player === opponent && dest.count > 1)) return true;
                            }
                            // Bear Off Move
                            else if (canBearOff) {
                                if (playerColor === PLAYER_HUMAN) {
                                    if (target === -1) return true;
                                    let higherPieces = false;
                                    for (let h = i + 1; h <= 5; h++) {
                                        if (currentBoard[h].player === playerColor && currentBoard[h].count > 0) higherPieces = true;
                                    }
                                    if (!higherPieces) return true;
                                } else {
                                    if (target === 24) return true;
                                    let higherPieces = false;
                                    for (let h = 18; h < i; h++) {
                                        if (currentBoard[h].player === playerColor && currentBoard[h].count > 0) higherPieces = true;
                                    }
                                    if (!higherPieces) return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };

            // Monitor Human Moves
            useEffect(() => {
                if (turn === 'human' && !rolling && dice.length > 0) {
                    const canMove = checkHumanCanMove(board, bar, dice);
                    if (!canMove) {
                        log("No valid moves possible. Undo to retry, or Pass.");
                        setIsBlocked(true);
                        // Do NOT auto-end. Let user decide.
                    } else {
                        setIsBlocked(false); // If moves are possible, ensure not blocked
                    }
                }
            }, [dice, turn, rolling, board, bar, playerColor]);

            // AI TURN
            useEffect(() => {
                if (gameStatus === 'playing' && turn === 'ai') {
                    // Give user time to Undo their last move before AI takes over
                    const timer = setTimeout(() => {
                        playAITurn();
                    }, 3000); // 3 seconds delay
                    return () => clearTimeout(timer);
                }
            }, [turn, gameStatus]);

            const playAITurn = () => {
                try {
                    log("AI Rolling...");

                    performRoll((aiDice) => {
                        log(`AI Rolled: ${aiDice.join(', ')}`);

                        // --- AI PRO LOGIC (Full Search) ---
                        const getBestSequence = (startBoard, startBar, dicePool) => {
                            let bestSeq = [];
                            let maxScore = -Infinity;
                            let maxDiceUsed = -1;
                            let maxDiceValSum = -1;

                            // Evaluation Function (Static Board State)
                            const evaluateBoard = (bd, br) => {
                                let score = 0;

                                // --- PHASE DETECTION: BEAR OFF ---
                                let allHome = true;
                                if (br[PLAYER_AI] > 0) allHome = false;
                                else {
                                    for (let i = 0; i <= 17; i++) {
                                        if (bd[i].player === PLAYER_AI && bd[i].count > 0) {
                                            allHome = false; break;
                                        }
                                    }
                                }

                                if (allHome) {
                                    // STRATEGY: Bear Off + Safety (Avoid Blots)
                                    let piecesOnBoard = 0;
                                    for (let i = 18; i < 24; i++) {
                                        if (bd[i].player === PLAYER_AI) piecesOnBoard += bd[i].count;
                                    }
                                    // Huge Bonus for every piece removed (15 total start)
                                    score += (15 - piecesOnBoard) * 100000;

                                    // Safety Check
                                    for (let i = 18; i < 24; i++) {
                                        if (bd[i].player === PLAYER_AI && bd[i].count === 1) {
                                            // BLOT PENALTY
                                            // Very dangerous if opponent has pieces on bar or in our home board
                                            score -= 50000;
                                        }
                                    }
                                    return score;
                                }

                                // --- NORMAL STRATEGY ---
                                // 1. Hitting Opponent (Opponent on Bar)
                                score += (br[PLAYER_HUMAN] * 10000);

                                // 2. Board Analysis
                                for (let i = 0; i < 24; i++) {
                                    const p = bd[i];
                                    if (p.player === PLAYER_AI) {
                                        if (p.count === 1) {
                                            // BLOT (Danger)
                                            score -= 2000;
                                        } else if (p.count > 1) {
                                            // GATE/POINT (Good)
                                            score += 1000;
                                            if (i >= 18) score += 2000; // House Priority
                                            if (i >= 7 && i <= 12) score += 500; // Prime Priority
                                        }
                                    }
                                }
                                return score;
                            };

                            // Recursive Search
                            const search = (currentBoard, currentBar, currentDice, moveSeq) => {
                                // Maximize Dice Used First
                                // If we used more dice than max found, this is new best tier
                                const diceUsed = moveSeq.length;

                                // Valid moves check
                                let validMovesFound = false;

                                // Optimization: If seq is full (based on dicePool size), eval immediately
                                // Wait, Backgammon rules: Must use max dice possible.

                                const uniqueDice = [...new Set(currentDice)]; // Try each unique die value available

                                for (let die of uniqueDice) {
                                    // Find all possible sources for this die
                                    // 1. From Bar
                                    if (currentBar[PLAYER_AI] > 0) {
                                        const target = die - 1; // AI enters 0..5 based on dice 1..6
                                        // Validation
                                        if (target >= 0 && target <= 23) { // Bounds
                                            const dest = currentBoard[target];
                                            if (!(dest.player === PLAYER_HUMAN && dest.count > 1)) {
                                                // Valid Move
                                                validMovesFound = true;

                                                // Apply Move
                                                const nextBoard = JSON.parse(JSON.stringify(currentBoard));
                                                const nextBar = { ...currentBar };
                                                nextBar[PLAYER_AI]--;
                                                let action = 'move';

                                                // Hit Logic
                                                if (nextBoard[target].player === PLAYER_HUMAN) {
                                                    nextBar[PLAYER_HUMAN]++;
                                                    nextBoard[target] = { player: PLAYER_AI, count: 1 };
                                                    action = 'hit';
                                                } else {
                                                    nextBoard[target].player = PLAYER_AI;
                                                    nextBoard[target].count++;
                                                }

                                                // Recurse
                                                const nextDice = [...currentDice];
                                                nextDice.splice(nextDice.indexOf(die), 1);

                                                search(nextBoard, nextBar, nextDice, [...moveSeq, {
                                                    from: 'bar', to: target, dieVal: die, action
                                                }]);
                                            }
                                        }
                                    }
                                    // 2. From Board (Only if Bar is empty)
                                    else {
                                        for (let i = 0; i < 24; i++) {
                                            if (currentBoard[i].player === PLAYER_AI) {
                                                const target = i + die;
                                                // Normal Move
                                                if (target <= 23) {
                                                    const dest = currentBoard[target];
                                                    if (!(dest.player === PLAYER_HUMAN && dest.count > 1)) {
                                                        // Valid Move
                                                        validMovesFound = true;

                                                        const nextBoard = JSON.parse(JSON.stringify(currentBoard));
                                                        const nextBar = { ...currentBar };
                                                        nextBoard[i].count--;
                                                        if (nextBoard[i].count === 0) nextBoard[i].player = 0;

                                                        if (nextBoard[target].player === PLAYER_HUMAN) {
                                                            nextBar[PLAYER_HUMAN]++;
                                                            nextBoard[target] = { player: PLAYER_AI, count: 1 };
                                                        } else {
                                                            nextBoard[target].player = PLAYER_AI;
                                                            nextBoard[target].count++;
                                                        }

                                                        const nextDice = [...currentDice];
                                                        nextDice.splice(nextDice.indexOf(die), 1);

                                                        search(nextBoard, nextBar, nextDice, [...moveSeq, {
                                                            from: i, to: target, dieVal: die
                                                        }]);
                                                    }
                                                }
                                                // Bear Off Move
                                                else {
                                                    // Check if AI can bear off (All pieces in 18-23)
                                                    let aiCanBearOff = true;
                                                    if (currentBar[PLAYER_AI] > 0) aiCanBearOff = false;
                                                    else {
                                                        for (let z = 0; z < 18; z++) {
                                                            if (currentBoard[z].player === PLAYER_AI && currentBoard[z].count > 0) {
                                                                aiCanBearOff = false;
                                                                break;
                                                            }
                                                        }
                                                    }

                                                    if (aiCanBearOff) {
                                                        let validBearOff = false;
                                                        if (target === 24) validBearOff = true; // Exact check
                                                        else {
                                                            // Over-bear check: Allow if no pieces on lower indices (18..i) in Home
                                                            // For AI (0->24), pieces "behind" are at indices < i.
                                                            // Home starts at 18. So check 18 to i-1.
                                                            let lowerPieces = false;
                                                            for (let b = 18; b < i; b++) {
                                                                if (currentBoard[b].player === PLAYER_AI && currentBoard[b].count > 0) lowerPieces = true;
                                                            }
                                                            if (!lowerPieces) validBearOff = true;
                                                        }

                                                        if (validBearOff) {
                                                            validMovesFound = true;
                                                            const nextBoard = JSON.parse(JSON.stringify(currentBoard));
                                                            const nextBar = { ...currentBar };
                                                            nextBoard[i].count--;
                                                            if (nextBoard[i].count === 0) nextBoard[i].player = 0;

                                                            const nextDice = [...currentDice];
                                                            nextDice.splice(nextDice.indexOf(die), 1);

                                                            // Use -1 logic (or 24?) for Bear Off destination? 
                                                            // We used -1 for Human. Let's use -1 for AI too to signify 'Off Board'. 
                                                            // The visualizer MUST handle this.
                                                            search(nextBoard, nextBar, nextDice, [...moveSeq, {
                                                                from: i, to: -1, dieVal: die, action: 'bearoff'
                                                            }]);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                // If no moves could be made (Leaf Node decision)
                                if (!validMovesFound) {
                                    // Rule: Must use max dice. 
                                    // Rule 2: If dice count equal, must use max VALUE (Pips).
                                    const diceUsed = moveSeq.length;
                                    const valSum = moveSeq.reduce((a, b) => a + b.dieVal, 0);

                                    if (diceUsed > maxDiceUsed) {
                                        maxDiceUsed = diceUsed;
                                        maxDiceValSum = valSum;
                                        maxScore = evaluateBoard(currentBoard, currentBar);
                                        bestSeq = moveSeq;
                                    } else if (diceUsed === maxDiceUsed) {
                                        if (valSum > maxDiceValSum) {
                                            maxDiceValSum = valSum;
                                            maxScore = evaluateBoard(currentBoard, currentBar);
                                            bestSeq = moveSeq;
                                        } else if (valSum === maxDiceValSum) {
                                            const score = evaluateBoard(currentBoard, currentBar);
                                            if (score > maxScore) {
                                                maxScore = score;
                                                bestSeq = moveSeq;
                                            }
                                        }
                                    }
                                }
                            };

                            search(startBoard, startBar, dicePool, []);
                            return bestSeq;
                        };


                        // Determine Moves
                        let sequence = [];
                        if (difficulty === 'beginner') {
                            // Keep random simple recursive logic? 
                            // Actually, for beginner, just run search with BAD evaluation? 
                            // Or just use the first valid random path found?
                            // Let's stick to the high-quality search for now as the user requested "Pro". 
                            // Beginner can just pick random moves locally (revert to random if needed, but lets just make AI smart overall first).
                            // To allow beginner, we can inject noise into `evaluateBoard`.
                            sequence = getBestSequence(board, bar, aiDice); // Just use smart for now
                        } else {
                            // Advanced
                            sequence = getBestSequence(board, bar, aiDice);
                        }

                        if (sequence.length === 0) {
                            log("AI has no moves.");
                            setTurn('human');
                            setCanRoll(true);
                            setDice([]);
                            setVisualDice([]);
                            setHistory([]);
                            return;
                        }

                        log(`AI found BEST path: ${sequence.length} moves.`);

                        // EXECUTE SEQUENCE WITH VISUAL DELAY
                        const runSequence = (seq, idx, currBoard, currBar) => {
                            if (idx >= seq.length) {
                                setTimeout(() => {
                                    log("AI Turn Ends.");
                                    setTurn('human');
                                    setCanRoll(true);
                                    setDice([]);
                                    setVisualDice([]);
                                    setHistory([]);
                                }, 800);
                                return;
                            }

                            const move = seq[idx];
                            setTimeout(() => {
                                // Update State Visuals
                                setBoard(prev => {
                                    const nb = [...prev]; // Should match currBoard logic ideally, but we re-apply for React State
                                    // Apply logic again strictly based on move param
                                    // NOTE: We use the Logic derived in Search to ensure consistency
                                    if (move.from === 'bar') {
                                        setBar(b => {
                                            const newBarState = { ...b };
                                            newBarState[PLAYER_AI]--;
                                            // If the move was a hit, the bar state for PLAYER_HUMAN would have changed in the search.
                                            // We need to reflect that here.
                                            // The `currBar` passed to `runSequence` is the state *before* any moves in the sequence.
                                            // The `move.action` property can help here.
                                            if (move.action === 'hit') {
                                                newBarState[PLAYER_HUMAN]++;
                                                log("AI Hits!");
                                            }
                                            return newBarState;
                                        });
                                    } else {
                                        const src = { ...nb[move.from] }; // Create a copy to avoid direct mutation
                                        src.count--;
                                        if (src.count === 0) src.player = 0;
                                        nb[move.from] = src;
                                    }

                                    playMoveSound();
                                    if (move.to === -1) {
                                        log("AI Bears Off.");
                                        setOff(prev => ({ ...prev, [PLAYER_AI]: prev[PLAYER_AI] + 1 }));
                                    } else {
                                        const dst = { ...nb[move.to] }; // Create a copy
                                        if (dst.player === PLAYER_HUMAN) {
                                            setBar(b => ({ ...b, [PLAYER_HUMAN]: b[PLAYER_HUMAN] + 1 }));
                                            dst.count = 1;
                                            dst.player = PLAYER_AI;
                                            log("AI Hits!");
                                        } else {
                                            dst.player = PLAYER_AI;
                                            dst.count++;
                                        }
                                        nb[move.to] = dst;
                                    }
                                    return nb;
                                });

                                // Remove used die from Visual Dice
                                setDice(prev => {
                                    const newD = [...prev];
                                    const dIdx = newD.indexOf(move.dieVal);
                                    if (dIdx > -1) newD.splice(dIdx, 1);
                                    return newD;
                                });

                                // Propagate tracking state for next step (Hit counts etc)
                                // We can just rely on the Search's plan.

                                runSequence(seq, idx + 1, null, null); // currBoard and currBar are not needed for subsequent steps as state is updated via setBoard/setBar

                            }, 1000);
                        };

                        runSequence(sequence, 0, board, bar);
                    });
                } catch (e) {
                    console.error("AI Error:", e);
                    log("AI Error: " + e.message);
                }
            };

            // HUMAN MOVES
            const handlePointClick = (index) => {
                if (turn !== 'human') return;
                if (rolling) return;

                // Select Source
                if (selectedPoint === null) {
                    if (bar[playerColor] > 0) return log("Must enter from bar!");

                    const isMyPiece = board[index].player === playerColor;
                    if (isMyPiece && board[index].count > 0) {
                        setSelectedPoint(index);

                        // Calculate Valid Moves
                        const possibleMoves = [];

                        // Check for Bear Off Condition
                        let canBearOff = true;
                        if (bar[playerColor] > 0) canBearOff = false;
                        else {
                            if (playerColor === PLAYER_HUMAN) {
                                // White Bear Off: All pieces in 0-5
                                for (let i = 6; i < 24; i++) {
                                    if (board[i].player === PLAYER_HUMAN && board[i].count > 0) {
                                        canBearOff = false;
                                        break;
                                    }
                                }
                            } else {
                                // Red Bear Off: All pieces in 18-23. (So check 0-17)
                                for (let i = 0; i < 18; i++) {
                                    if (board[i].player === PLAYER_AI && board[i].count > 0) {
                                        canBearOff = false;
                                        break;
                                    }
                                }
                            }
                        }

                        [...new Set(dice)].forEach(d => {
                            // Direction: White (-) Red (+)
                            const target = playerColor === PLAYER_HUMAN ? index - d : index + d;

                            // Bounds Check
                            const inBounds = target >= 0 && target <= 23;

                            if (inBounds) {
                                const dest = board[target];
                                // Blocked by Opponent?
                                const opponent = playerColor === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN;
                                const isBlocked = dest.player === opponent && dest.count > 1;
                                if (!isBlocked) possibleMoves.push(target);
                            } else if (canBearOff) {
                                // Bear Off Logic
                                // White: target < 0. Red: target > 23.
                                const isBearOffMove = playerColor === PLAYER_HUMAN ? target < 0 : target > 23;

                                if (isBearOffMove) {
                                    // 1. Exact Bearoff? 
                                    // White: index - d == -1 => index + 1 == d.
                                    // Red: index + d == 24. 
                                    const exact = playerColor === PLAYER_HUMAN ? (index - d === -1) : (index + d === 24);

                                    if (exact) {
                                        possibleMoves.push(-1);
                                    } else {
                                        // 2. Higher Die Bearoff?
                                        // Only allowed if no pieces on higher points.

                                        let hasHigher = false;
                                        if (playerColor === PLAYER_HUMAN) {
                                            // White: check indices > index up to 5
                                            for (let k = index + 1; k <= 5; k++) {
                                                if (board[k].player === playerColor && board[k].count > 0) hasHigher = true;
                                            }
                                        } else {
                                            // Red: check indices < index down to 18
                                            for (let k = index - 1; k >= 18; k--) {
                                                if (board[k].player === playerColor && board[k].count > 0) hasHigher = true;
                                            }
                                        }

                                        if (!hasHigher) possibleMoves.push(-1);
                                    }
                                }
                            }
                        });
                        setValidMoves(possibleMoves);
                    }
                }
                // Destination Click
                else {
                    if (index === selectedPoint) {
                        setSelectedPoint(null);
                        setValidMoves([]);
                        return;
                    }

                    if (!validMoves.includes(index)) {
                        // Check ownership for re-selection
                        if (selectedPoint !== 'bar' && index >= 0 && board[index].player === playerColor && board[index].count > 0) {
                            setSelectedPoint(null);
                            setValidMoves([]);
                            handlePointClick(index); // Recursive re-select
                            return;
                        }
                        log("Invalid move!");
                        return;
                    }

                    // EXECUTE MOVE
                    playMoveSound();
                    const snapshot = {
                        board: JSON.parse(JSON.stringify(board)),
                        bar: { ...bar },
                        dice: [...dice],
                        turn: turn
                    };

                    setHistory(prev => [...prev, snapshot]);

                    // Calculate distance and die
                    let dieUsed;
                    const dir = playerColor === PLAYER_HUMAN ? -1 : 1;

                    if (selectedPoint === 'bar') {
                        // Bar Entry
                        // White: Enters at 24 - die. Die = 24 - index.
                        // Red: Enters at die - 1. Die = index + 1.
                        if (playerColor === PLAYER_HUMAN) {
                            dieUsed = 24 - index;
                        } else {
                            dieUsed = index + 1;
                        }
                    } else {
                        if (index === -1) {
                            // Bear Off
                            // White: selected - die = -1 => die = selected + 1
                            // Red: selected + die = 24 => die = 24 - selected
                            if (playerColor === PLAYER_HUMAN) {
                                const exactDie = selectedPoint + 1;
                                dieUsed = dice.includes(exactDie) ? exactDie : (dice.find(d => selectedPoint - d < -1) || exactDie);
                            } else {
                                const exactDie = 24 - selectedPoint;
                                dieUsed = dice.includes(exactDie) ? exactDie : (dice.find(d => selectedPoint + d > 23) || exactDie);
                            }
                        } else {
                            // Standard Move
                            // White: selected - index.
                            // Red: index - selected.
                            dieUsed = Math.abs(selectedPoint - index);
                        }
                    }
                    const dieIdx = dice.indexOf(dieUsed);

                    // Update Board
                    const nextBoard = [...board];
                    const nextBar = { ...bar };
                    const nextOff = { ...off };
                    // const source = nextBoard[selectedPoint]; // Original line, now handled in else block

                    if (selectedPoint === 'bar') {
                        nextBar[playerColor]--;
                    } else {
                        const source = { ...nextBoard[selectedPoint] };
                        source.count--;
                        if (source.count === 0) source.player = 0;
                        nextBoard[selectedPoint] = source;
                    }

                    if (index === -1) {
                        // Bear Off
                        log("Bearing Off!");
                        nextOff[playerColor]++;
                    } else {
                        const dest = { ...nextBoard[index] };
                        const opponent = playerColor === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN;

                        if (dest.player === opponent) {
                            // Hit
                            log("Checkers Hit!");
                            nextBar[opponent] = nextBar[opponent] + 1;
                            dest.player = playerColor;
                            dest.count = 1;
                        } else {
                            dest.player = playerColor;
                            dest.count += 1;
                        }
                        nextBoard[index] = dest;
                    }

                    // Apply State
                    setBoard(nextBoard);
                    setBar(nextBar);
                    setOff(nextOff);

                    // 3. Consume Dice
                    const newDice = [...dice];
                    newDice.splice(dieIdx, 1);
                    setDice(newDice);

                    if (gameMode === 'multi') {
                        // Use state_update to include dice (so opponent sees dice consumed)
                        emitGameEvent('state_update', { board: nextBoard, bar: nextBar, off: nextOff, dice: newDice });
                    }

                    // Reset
                    setSelectedPoint(null);
                    setValidMoves([]);

                    // Check if *remaining* dice have any valid moves
                    if (newDice.length > 0 && !checkHumanCanMove(nextBoard, nextBar, newDice)) {
                        log("No valid moves left. Undo to retry, or Pass.");
                        setIsBlocked(true);
                        // Do NOT auto-end. Let user decide.
                    }

                    if (newDice.length === 0) {
                        handlePassTurn();
                    }
                }
            };

            // Bar Click handler
            const handleBarClick = () => {
                if (turn !== 'human') return; // 'human' here means 'MY turn' locally

                const myBarCount = bar[playerColor];
                if (myBarCount > 0) {
                    setSelectedPoint('bar');

                    const possibleMoves = [];
                    // Logic depends on Color
                    // White (Standard): Enters at 24 - die (Index 18..23)
                    // Red (Flipped/Opponent): Enters at 0 + die (Index 0..5)? No.
                    // Red moves 1 -> 24. Enters at 1. White Home is 1..6.
                    // So Red enters into Indices 0..5.
                    // Target = die - 1. (Die 1 -> Index 0)

                    [...new Set(dice)].forEach(d => {
                        let target;
                        if (playerColor === PLAYER_AI) {
                            target = d - 1; // 1-based die to 0-based index
                        } else {
                            target = 24 - d;
                        }

                        if (target >= 0 && target <= 23) {
                            const dest = board[target];
                            // Check blockage. I am blocked by OPPONENT.
                            // If I am PLAYER_AI, Opponent is PLAYER_HUMAN.
                            const opponent = playerColor === PLAYER_HUMAN ? PLAYER_AI : PLAYER_HUMAN;
                            const blocked = dest.player === opponent && dest.count > 1;

                            if (!blocked) possibleMoves.push(target);
                        }
                    });
                    setValidMoves(possibleMoves);
                    log("Select a valid point to enter.");
                }
            };

            // WIN CHECKER
            useEffect(() => {
                if (gameStatus !== 'playing') return;

                const countHuman = board.reduce((acc, p) => p.player === PLAYER_HUMAN ? acc + p.count : acc, 0) + bar[PLAYER_HUMAN];
                const countAI = board.reduce((acc, p) => p.player === PLAYER_AI ? acc + p.count : acc, 0) + bar[PLAYER_AI];

                // Determine "My" pieces and "Opponent" pieces
                const myPieces = playerColor === PLAYER_HUMAN ? countHuman : countAI;
                const oppPieces = playerColor === PLAYER_HUMAN ? countAI : countHuman;

                if (myPieces === 0) {
                    setGameStatus('gameover');
                    setGameResult('win'); // "YOU WIN"
                    playDiceSound();
                    updateStats('win');

                    // Payout Logic
                    const stake = selectedStakeRef.current;
                    if (stake > 0) {
                        // Win = Return Stake + Opponent Stake (minus fee?)
                        // Simple 2x return for MVP
                        const confirmWin = stake * 2;
                        const fee = confirmWin * 0.02; // 2% Fee
                        const payout = confirmWin - fee;

                        setEscrowBalance(prev => parseFloat((prev + payout).toFixed(2)));
                        log(`Won ${payout.toFixed(3)} SOL! Added to Escrow.`);
                    }

                } else if (oppPieces === 0) {
                    setGameStatus('gameover');
                    setGameResult('loss');
                    updateStats('loss');
                }
            }, [board, bar, gameStatus, playerColor]);

            // RENDER
            // 1. LANDING PAGE
            if (gameStatus === 'menu') {
                return (
                    <div className="landing-page">
                        <div className="landing-visual">
                            <div className="landing-die die-1 face-6">
                                <div className="dot"></div><div className="dot"></div>
                                <div className="dot"></div><div className="dot"></div>
                                <div className="dot"></div><div className="dot"></div>
                            </div>
                            <div className="landing-die die-2 face-5">
                                <div className="dot"></div><div className="dot"></div>
                                <div className="dot"></div><div className="dot"></div>
                                <div className="dot"></div>
                            </div>
                        </div>

                        <div className="landing-title">
                            <span style={{ color: '#d32f2f', WebkitTextFillColor: 'initial', background: 'none' }}>Play</span>
                            <span style={{ color: '#fff', WebkitTextFillColor: 'initial', background: 'none' }}>24</span>
                            <span style={{ color: '#e8e0d5', WebkitTextFillColor: 'initial', background: 'none' }}> Backgammon</span>
                        </div>
                        <div className="landing-subtitle">Powered by Solana</div>

                        {/* Top Right Wallet Badge (Only if connected) */}
                        {wallet && (
                            <>
                                {/* Top Left Wallet Info */}
                                <div className="wallet-badge-container">
                                    {wallet.startsWith('Guest') ? (
                                        <div className="wallet-badge">Guest Mode</div>
                                    ) : (
                                        <div className="wallet-badge">
                                            <span>
                                                {userProfile.name || `${wallet.slice(0, 4)}...${wallet.slice(-4)}`}
                                            </span>
                                            <span style={{ opacity: 0.6 }}>|</span>
                                            <span>{balance} SOL</span>
                                        </div>
                                    )}
                                </div>

                                {/* Top Right Disconnect */}
                                <div style={{ position: 'absolute', top: '20px', right: '20px', zIndex: 1001 }}>
                                    <button className="btn-disconnect" onClick={() => setWallet(null)}>
                                        {wallet.startsWith('Guest') ? 'Exit Guest' : 'Disconnect'}
                                    </button>
                                </div>
                            </>
                        )}

                        {/* PROFILE MODAL */}
                        {isProfileModalOpen && (
                            <div className="modal-overlay">
                                <div className="modal-content">
                                    <h3>Edit Profile</h3>
                                    <div className="form-group">
                                        <label>Display Name</label>
                                        <input
                                            type="text"
                                            id="input-name"
                                            defaultValue={userProfile.name}
                                            placeholder="Enter your name"
                                            className="modal-input"
                                        />
                                    </div>
                                    <div className="form-group">
                                        <label>Avatar</label>
                                        <input
                                            type="file"
                                            id="input-file"
                                            accept="image/*"
                                            className="modal-input"
                                        />
                                    </div>
                                    <div className="modal-actions">
                                        <button className="btn-secondary" onClick={() => setIsProfileModalOpen(false)}>Cancel</button>
                                        <button className="btn-primary" onClick={() => {
                                            const name = document.getElementById('input-name').value;
                                            const fileInput = document.getElementById('input-file');

                                            if (fileInput.files && fileInput.files[0]) {
                                                const reader = new FileReader();
                                                reader.onload = (e) => {
                                                    handleSaveProfile(name, e.target.result);
                                                };
                                                reader.readAsDataURL(fileInput.files[0]);
                                            } else {
                                                handleSaveProfile(name, userProfile.avatar);
                                            }
                                        }}>Save</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* WALLET SELECTOR MODAL (Mobile) */}
                        {isWalletSelectorOpen && (
                            <div className="modal-overlay">
                                <div className="modal-content" style={{ maxWidth: '350px' }}>
                                    <h3>Select Wallet</h3>
                                    <p style={{ fontSize: '0.9rem', color: '#aaa', marginBottom: '20px' }}>Select your wallet app to open this game:</p>

                                    <div className="form-group" style={{ display: 'flex', flexDirection: 'column', gap: '10px' }}>

                                        {/* Phantom */}
                                        <button className="btn-primary" style={{ backgroundColor: '#AB9FF2', color: '#222', border: 'none' }} onClick={() => {
                                            const url = window.location.href;
                                            window.location.href = `https://phantom.app/ul/browse/${encodeURIComponent(url)}?ref=${encodeURIComponent(url)}`;
                                        }}>
                                            Phantom
                                        </button>

                                        {/* Solflare */}
                                        <button className="btn-primary" style={{ backgroundColor: '#FC7429', color: '#fff', border: 'none' }} onClick={() => {
                                            const url = window.location.href;
                                            window.location.href = `https://solflare.com/ul/v1/browse/${encodeURIComponent(url)}`;
                                        }}>
                                            Solflare
                                        </button>

                                        {/* Solana Seeker / Mobile */}
                                        <button className="btn-primary" style={{ backgroundColor: '#000', color: '#fff', border: '1px solid #333', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px' }} onClick={() => {
                                            if (window.solana) {
                                                // If running inside Seeker/Saga browser, generic connect should work via Seed Vault injection
                                                connectWallet();
                                                setIsWalletSelectorOpen(false);
                                            } else {
                                                const url = window.location.href;
                                                navigator.clipboard.writeText(url).then(() => alert("Link Copied! Open this in the dApp Store or a Wallet Browser on your Seeker."));
                                            }
                                        }}>
                                            <span style={{ fontSize: '1.2rem' }}></span>
                                            <div style={{ textAlign: 'left' }}>
                                                <div>Seeker / Seed Vault</div>
                                                <div style={{ fontSize: '0.7rem', color: '#aaa' }}>Open in dApp Store</div>
                                            </div>
                                        </button>

                                    </div>
                                    <div className="modal-actions" style={{ marginTop: '20px' }}>
                                        <button className="btn-secondary" onClick={() => setIsWalletSelectorOpen(false)}>Cancel</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {!wallet ? (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '15px' }}>
                                <button className="btn-primary" style={{ fontSize: '1.2rem', padding: '15px 30px', display: 'flex', alignItems: 'center', gap: '15px', justifyContent: 'center', minWidth: '250px' }} onClick={handleGuestLogin}>
                                    <span style={{ fontSize: '1.4rem' }}></span>
                                    <span>Guest Mode</span>
                                </button>
                                <button className="btn-primary" style={{ fontSize: '1.2rem', padding: '15px 30px', background: 'transparent', border: '1px solid #8d6e63', display: 'flex', alignItems: 'center', gap: '15px', justifyContent: 'center', minWidth: '250px' }} onClick={connectWallet}>
                                    <span style={{ fontSize: '1.4rem' }}></span>
                                    <span>Connect Wallet</span>
                                </button>
                            </div>
                        ) : (
                            <div className="landing-menu">
                                {/* Single Player Dropdown */}
                                <div className="dropdown-container">
                                    <div className="dropdown-header" onClick={() => setIsDropdownOpen(!isDropdownOpen)}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                            <span className="icon"></span>
                                            <span>Single Player</span>
                                        </div>
                                        <span>{isDropdownOpen ? '' : ''}</span>
                                    </div>
                                    <div className={`dropdown-options ${isDropdownOpen ? 'open' : ''}`}>
                                        <div className="dropdown-item" onClick={() => startGame('beginner')}>
                                            <span>Easy (Beginner)</span>
                                            <span></span>
                                        </div>
                                        <div className="dropdown-item" onClick={() => startGame('advanced')}>
                                            <span>Hard (Advanced)</span>
                                            <span></span>
                                        </div>
                                    </div>
                                </div>

                                <button className="btn-mode" onClick={() => setGameStatus('multiplayer_menu')}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                        <span className="icon"></span>
                                        <span>Multiplayer</span>
                                    </div>
                                    <span></span> {/* Spacer for flex-between */}
                                </button>

                                <button className="btn-mode" disabled>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                        <span className="icon"></span>
                                        <span>Tournament</span>
                                    </div>
                                    <span></span>
                                </button>

                                <button className="btn-mode" onClick={() => setGameStatus('leaderboard')}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                        <span className="icon"></span>
                                        <span>Stats / Leaderboard</span>
                                    </div>
                                    <span></span>
                                </button>
                            </div>
                        )}
                    </div>
                );
            }

            if (gameStatus === 'multiplayer_menu') {
                return (
                    <div className="landing-page">
                        {/* Top Right Wallet Badge (Replicated) */}
                        {wallet && (
                            <>
                                <div className="wallet-badge-container">
                                    {wallet.startsWith('Guest') ? (
                                        <div className="wallet-badge">Guest Mode</div>
                                    ) : (
                                        <div className="wallet-badge">
                                            <span>
                                                {userProfile.name || `${wallet.slice(0, 4)}...${wallet.slice(-4)}`}
                                            </span>
                                            <span style={{ opacity: 0.6 }}>|</span>
                                            <span>{balance} SOL</span>
                                        </div>
                                    )}
                                </div>
                                <div style={{ position: 'absolute', top: '20px', right: '20px', zIndex: 1001 }}>
                                    <button className="btn-disconnect" onClick={() => setWallet(null)}>
                                        {wallet.startsWith('Guest') ? 'Exit Guest' : 'Disconnect'}
                                    </button>
                                </div>
                            </>
                        )}

                        <h2 className="landing-title">Select Mode</h2>

                        {isSearching ? (
                            <div className="card" style={{ padding: '40px', textAlign: 'center', border: '2px solid #4caf50', background: 'rgba(0,0,0,0.8)' }}>
                                <div style={{ fontSize: '3rem', marginBottom: '20px' }}></div>
                                <h3>Searching for opponent...</h3>
                                <p style={{ color: '#aaa' }}>Stake: {selectedStake ? selectedStake + ' SOL' : 'Free Play'}</p>
                                <button className="btn-secondary" style={{ marginTop: '20px' }} onClick={() => setIsSearching(false)}>Cancel</button>
                            </div>
                        ) : (
                            <div style={{ display: 'flex', gap: '30px', flexWrap: 'wrap', justifyContent: 'center' }}>
                                {/* FREE PLAY */}
                                <div className="card" style={{ textAlign: 'center', width: '250px', cursor: 'pointer', border: '2px solid #8d6e63' }} onClick={() => handleSearchMatch(null)}>
                                    <div style={{ fontSize: '3rem', marginBottom: '10px' }}></div>
                                    <h3>Free Play</h3>
                                    <p style={{ color: '#aaa' }}>Practice against random peers.</p>
                                    <button className="btn-primary" style={{ marginTop: '15px', width: '100%' }}>Find Match</button>
                                </div>

                                {/* STAKE PLAY */}
                                <div className="card" style={{ textAlign: 'center', width: '300px', border: '2px solid gold' }}>
                                    <div style={{ fontSize: '3rem', marginBottom: '10px' }}></div>
                                    <h3>Ranked / Stake</h3>
                                    <p style={{ color: '#aaa' }}>Win SOL from opponents.</p>

                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', marginTop: '15px' }}>
                                        {[0.01, 0.02, 0.03, 0.04].map(amt => (
                                            <button key={amt} className="btn-secondary" onClick={() => handleSearchMatch(amt)}>
                                                {amt} SOL
                                            </button>
                                        ))}
                                    </div>

                                    {/* ESCROW CONTROLS */}
                                    <div style={{ marginTop: '20px', paddingTop: '10px', borderTop: '1px solid #4e342e' }}>
                                        <div style={{ color: '#aaa', fontSize: '0.9rem', marginBottom: '10px' }}>
                                            Escrow Balance: <span style={{ color: '#fff', fontWeight: 'bold' }}>{escrowBalance} SOL</span>
                                        </div>
                                        <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>
                                            <button className="btn-secondary" style={{ fontSize: '0.8rem', padding: '5px 10px', background: '#2e7d32' }} onClick={handleEscrowDeposit}>
                                                + Deposit
                                            </button>
                                            <button className="btn-secondary" style={{ fontSize: '0.8rem', padding: '5px 10px', background: '#c62828' }} onClick={handleEscrowWithdraw}>
                                                - Withdraw
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {!isSearching && (
                            <button className="btn-primary" style={{ marginTop: '40px', background: '#3e2723' }} onClick={() => setGameStatus('menu')}>Back to Menu</button>
                        )}
                    </div>
                );
            }



            if (gameStatus === 'leaderboard') {
                const leaderboard = getLeaderboard();
                return (
                    <div className="landing-page">
                        <h2 className="landing-title" style={{ fontSize: '2.5rem', marginBottom: '20px' }}>Top 20 Players</h2>
                        <div style={{
                            background: 'rgba(44, 36, 27, 0.95)',
                            padding: '20px',
                            borderRadius: '12px',
                            width: '90%',
                            maxWidth: '600px',
                            maxHeight: '60vh',
                            overflowY: 'auto',
                            marginBottom: '20px',
                            border: '1px solid #5d4037'
                        }}>
                            {leaderboard.map((p, i) => (
                                <div key={i} style={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'space-between',
                                    padding: '15px',
                                    borderBottom: '1px solid #3e2723',
                                    background: i === 0 ? 'rgba(255, 215, 0, 0.1)' : 'transparent'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                                        <div style={{ fontSize: '1.2rem', fontWeight: 'bold', width: '30px', color: i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? '#cd7f32' : '#a1887f' }}>#{i + 1}</div>
                                        {p.avatar ? <img src={p.avatar} style={{ width: '40px', height: '40px', borderRadius: '50%', border: '1px solid #5d4037', objectFit: 'cover' }} /> : <div className="dot" style={{ width: '40px', height: '40px', position: 'static', background: '#3e2723' }}></div>}
                                        <div>
                                            <div style={{ fontWeight: 'bold', color: '#e8e0d5' }}>{p.name || 'Unknown'}</div>
                                            <div style={{ fontSize: '0.8rem', color: '#aaa' }}>Lvl {p.stats?.level || 1}  {p.stats?.wins || 0} Wins</div>
                                        </div>
                                    </div>
                                    <div style={{ fontSize: '1.1rem', fontWeight: 'bold', color: '#ffca28' }}>
                                        {p.stats?.xp || 0} XP
                                    </div>
                                </div>
                            ))}
                        </div>
                        <button className="btn-primary" style={{ background: '#3e2723', padding: '10px 40px' }} onClick={() => setGameStatus('menu')}>Back to Menu</button>
                    </div>
                );
            }

            // Helper for specific Perspective Rendering
            // Helper for specific Perspective Rendering
            const isFlipped = playerColor === PLAYER_AI;
            const getLogIdx = (i) => isFlipped ? (i + 12) % 24 : i;

            // 2. GAME BOARD
            return (
                <div className="app-container">
                    {/* SIDEBAR */}
                    <div className="sidebar">
                        <div className="logo">
                            <span style={{ color: '#d32f2f' }}>Play</span><span style={{ color: '#fff' }}>24</span><br />Backgammon
                            <div style={{ display: 'flex', gap: '8px', marginTop: '10px', justifyContent: 'center' }}>
                                <div style={{ width: '14px', height: '14px', background: '#fff', borderRadius: '3px', boxShadow: '0 2px 4px rgba(0,0,0,0.5)' }}></div>
                                <div style={{ width: '14px', height: '14px', background: '#d32f2f', borderRadius: '3px', boxShadow: '0 2px 4px rgba(0,0,0,0.5)' }}></div>
                            </div>
                        </div>

                        <div className="card">
                            <div className="label">Status</div>
                            <div className="value">
                                {turn === 'human' ? 'Your Turn' : (gameMode === 'multi' ? 'Wait...' : 'AI Thinking...')}
                            </div>
                            {turn === 'human' && (
                                <div style={{ marginTop: '5px', fontSize: '0.9rem', color: turnTimer < 30 ? '#ff5252' : '#aaa' }}>
                                    Time: {Math.floor(turnTimer / 60)}:{(turnTimer % 60).toString().padStart(2, '0')}
                                </div>
                            )}
                        </div>



                        <div className="logs">
                            {logs.map((L, i) => <div key={i} className="log-item">{L}</div>)}
                        </div>

                        <div className="spacer"></div>

                        {/* Wallet Info Hidden */}
                        {/* <div className="wallet-info">...</div> */}

                        <div className="card"
                            style={{ marginTop: 'auto', cursor: 'pointer', textAlign: 'center', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px', background: '#3e2723', borderColor: '#4e342e' }}
                            onClick={() => {
                                if (gameStatus === 'playing' || gameStatus === 'opening_roll') {
                                    if (window.confirm("Are you sure you want to resign?")) {
                                        handleForfeit();
                                    }
                                } else {
                                    setGameStatus('menu');
                                    setBoard(initialBoard);
                                    setGameResult(null);
                                    setVisualDice([]);
                                    setDice([]);
                                }
                            }}>
                            {gameStatus === 'playing' ? (
                                <><span></span> Resign</>
                            ) : (
                                <><span></span> Back to Menu</>
                            )}
                        </div>
                    </div>

                    {/* MAIN GAME AREA */}
                    <div className="board-wrapper">

                        {/* OPPONENT BAR */}
                        <div className={`opponent-bar ${turn === 'ai' || turn === 'opponent' ? 'active-turn' : ''}`}>
                            <div className="opponent-info">
                                <div className="opponent-avatar" style={{
                                    background: playerColor === PLAYER_HUMAN
                                        ? 'radial-gradient(circle at 30% 30%, #4a4a4a, #000000)' // If I am White, Opponent is Red (Black/Red styling)
                                        : 'radial-gradient(circle at 30% 30%, #ffffff, #dcdcdc)', // If I am Red, Opponent is White
                                    borderColor: playerColor === PLAYER_HUMAN ? '#000' : '#b0b0b0'
                                }}></div>
                                <div className="opponent-name">
                                    <div style={{ fontWeight: 'bold' }}>{gameMode === 'multi' ? opponentName : `Computer (${difficulty === 'advanced' ? 'Pro' : 'Novice'})`}</div>
                                    <div style={{ fontSize: '0.8rem', color: '#aaa', marginTop: '2px', display: 'flex', alignItems: 'center', gap: '6px' }}>
                                        {gameMode === 'multi' ? (
                                            <>
                                                {opponentWallet && (!opponentName || !opponentName.includes('...')) && (
                                                    <span style={{ fontFamily: 'monospace', color: '#ffecb3', opacity: 0.8 }}>
                                                        {opponentWallet.slice(0, 4)}...{opponentWallet.slice(-4)}
                                                    </span>
                                                )}
                                                {opponentWallet && (!opponentName || !opponentName.includes('...')) && <span></span>}
                                                <span>Lvl {opponentLevel}</span>
                                            </>
                                        ) : (
                                            'Level 100'
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* GAME OVER OVERLAY */}
                        {gameStatus === 'gameover' && (
                            <div className="game-over-overlay">
                                <div className={`game-over-title ${gameResult}`}>
                                    {gameResult === 'win' ? 'YOU WIN!' : 'YOU LOST!'}
                                </div>
                                <div className="game-over-subtitle">
                                    {gameResult === 'win' ? 'Great moves! You dominated the board.' : 'Better luck next time!'}
                                </div>
                                <div style={{ display: 'flex', gap: '20px', justifyContent: 'center' }}>
                                    <button className="btn-primary" onClick={() => {
                                        setGameStatus('menu');
                                        setBoard(initialBoard);
                                        setGameResult(null);
                                    }}>Back to Menu</button>
                                    <button className="btn-primary" style={{ background: '#4caf50', border: '1px solid #81c784' }} onClick={() => {
                                        setBoard(initialBoard);
                                        setBar({ 0: 0, 1: 0 });
                                        setGameResult(null);

                                        if (gameMode === 'multi') {
                                            setGameStatus('multiplayer_menu');
                                            handleSearchMatch(selectedStake);
                                        } else {
                                            startGame(difficulty);
                                        }
                                    }}>Play Again</button>
                                </div>
                            </div>
                        )}

                        {/* OPENING ROLL OVERLAY */}
                        {gameStatus === 'opening_roll' && (
                            <div className="game-over-overlay" style={{ background: 'rgba(0,0,0,0.92)', zIndex: 900 }}>
                                <div className="game-over-title" style={{ fontSize: '2rem', marginBottom: '10px', color: '#fff' }}>Opening Roll</div>
                                <div className="game-over-subtitle" style={{ marginBottom: '20px' }}>
                                    Roll to decide who moves first!
                                </div>

                                {(openingRoll || rolling) ? (
                                    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: '60px', margin: '30px 0' }}>
                                        <div style={{ textAlign: 'center' }}>
                                            <div style={{ color: '#fff', marginBottom: '10px', fontWeight: 'bold', fontSize: '1.2rem' }}>YOU</div>
                                            {(openingRoll && openingRoll.human) ? (
                                                <div className="die-3d" style={{ width: '70px', height: '70px', fontSize: '2.5rem', lineHeight: '70px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>{openingRoll.human}</div>
                                            ) : (
                                                rolling ? (
                                                    <div className="die-3d" style={{ width: '70px', height: '70px', animation: 'spin 1s infinite linear' }}></div>
                                                ) : (
                                                    <div className="die-3d" style={{ width: '70px', height: '70px', display: 'flex', alignItems: 'center', justifyContent: 'center', border: '2px dashed #666', background: 'transparent', color: '#666', fontSize: '2rem' }}>?</div>
                                                )
                                            )}
                                        </div>
                                        <div style={{ fontSize: '1.5rem', color: '#aaa', paddingTop: '20px' }}>vs</div>
                                        <div style={{ textAlign: 'center' }}>
                                            <div style={{ color: '#d32f2f', marginBottom: '10px', fontWeight: 'bold', fontSize: '1.2rem' }}>{gameMode === 'multi' ? opponentName : 'AI'}</div>
                                            {(openingRoll && openingRoll.ai) ? (
                                                <div className="die-3d" style={{ width: '70px', height: '70px', fontSize: '2.5rem', lineHeight: '70px', color: '#d32f2f', borderColor: '#d32f2f', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>{openingRoll.ai}</div>
                                            ) : (
                                                (gameMode === 'single' && rolling) ? (
                                                    <div className="die-3d" style={{ width: '70px', height: '70px', animation: 'spin 1s infinite linear', borderColor: '#d32f2f' }}></div>
                                                ) : (
                                                    <div className="die-3d" style={{ width: '70px', height: '70px', display: 'flex', alignItems: 'center', justifyContent: 'center', border: '2px dashed #d32f2f', background: 'transparent', color: '#d32f2f', fontSize: '2rem' }}>{gameMode === 'multi' ? '...' : '?'}</div>
                                                )
                                            )}
                                        </div>
                                    </div>
                                ) : (
                                    <div style={{ height: '80px', display: 'flex', alignItems: 'center', justifyContent: 'center', margin: '30px 0' }}>
                                        <div style={{ fontSize: '4rem' }}></div>
                                    </div>
                                )}

                                {(!openingRoll || !openingRoll.human) && !rolling && (
                                    <button className="btn-primary" style={{ fontSize: '1.3rem', padding: '15px 50px' }} onClick={handleOpeningRoll}>ROLL FOR FIRST TURN</button>
                                )}
                            </div>
                        )}

                        {/* DICE TABLE OVERLAY */}
                        <div className={`dice-table-overlay ${rolling ? 'rolling' : ''}`}>
                            {/* Turn Notification */}
                            {turn === 'human' && (canRoll || dice.length > 0) && !rolling && (
                                <div className="turn-message">YOUR TURN!</div>
                            )}

                            {(visualDice.length > 0 || rolling) && (
                                <div className="dice-pair">
                                    {rolling ? (
                                        <>
                                            <div className="die-3d"></div>
                                            <div className="die-3d"></div>
                                        </>
                                    ) : (
                                        visualDice.map((d, i) => <div key={i} className="die-3d">{d}</div>)
                                    )}
                                </div>
                            )}
                        </div>

                        {/* TOP HALF (Indices 12-23) */}
                        <OffTray
                            player={PLAYER_AI}
                            count={off[PLAYER_AI]}
                            position="top"
                        />
                        <div className="board-row top">
                            {/* 12-17 */}
                            <div className="quadrant">
                                {[12, 13, 14, 15, 16, 17].map(i => {
                                    const logical = getLogIdx(i);
                                    return <Point key={i} index={i} data={board[logical]} isTop={true} selected={selectedPoint === logical} isValid={validMoves.includes(logical)} onClick={() => handlePointClick(logical)} playerColor={playerColor} />
                                })}
                            </div>

                            {/* BAR TOP - OPPONENT (AI) */}
                            <div className="bar-center">
                                {bar[PLAYER_AI] > 0 && (
                                    <div
                                        className="checker red"
                                        onClick={playerColor === PLAYER_AI ? handleBarClick : undefined}
                                        style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 'bold', cursor: playerColor === PLAYER_AI ? 'pointer' : 'default', color: '#fff', fontSize: '1.2rem', position: 'relative', zIndex: 5 }}>
                                        {bar[PLAYER_AI]}
                                    </div>
                                )}
                            </div>

                            {/* 18-23 */}
                            <div className="quadrant">
                                {[18, 19, 20, 21, 22, 23].map(i => {
                                    const logical = getLogIdx(i);
                                    return <Point key={i} index={i} data={board[logical]} isTop={true} selected={selectedPoint === logical} isValid={validMoves.includes(logical)} onClick={() => handlePointClick(logical)} playerColor={playerColor} />
                                })}
                            </div>
                        </div>

                        {/* BOTTOM HALF (Indices 11-0) */}
                        {/* Bottom Left: 11-6. Bottom Right: 5-0 */}
                        <div className="board-row bottom">
                            {/* 11-6 */}
                            <div className="quadrant">
                                {[11, 10, 9, 8, 7, 6].map(i => {
                                    const logical = getLogIdx(i);
                                    return <Point key={i} index={i} data={board[logical]} isTop={false} selected={selectedPoint === logical} isValid={validMoves.includes(logical)} onClick={() => handlePointClick(logical)} playerColor={playerColor} />
                                })}
                            </div>

                            {/* BAR BOTTOM - PLAYER (HUMAN) */}
                            <div className="bar-center">
                                {bar[PLAYER_HUMAN] > 0 && (
                                    <div
                                        className="checker white"
                                        onClick={playerColor === PLAYER_HUMAN ? handleBarClick : undefined}
                                        style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', fontWeight: 'bold', cursor: playerColor === PLAYER_HUMAN ? 'pointer' : 'default', color: '#000', fontSize: '1.2rem', position: 'relative', zIndex: 5 }}
                                    >
                                        {bar[PLAYER_HUMAN]}
                                    </div>
                                )}
                            </div>

                            {/* 5-0 */}
                            <div className="quadrant">
                                {[5, 4, 3, 2, 1, 0].map(i => {
                                    const logical = getLogIdx(i);
                                    return <Point key={i} index={i} data={board[logical]} isTop={false} selected={selectedPoint === logical} isValid={validMoves.includes(logical)} onClick={() => handlePointClick(logical)} playerColor={playerColor} />
                                })}
                            </div>
                        </div>
                        <OffTray
                            player={PLAYER_HUMAN}
                            count={off[PLAYER_HUMAN]}
                            position="bottom"
                            valid={validMoves.includes(-1) && playerColor === PLAYER_HUMAN}
                            onClick={() => handlePointClick(-1)}
                        />

                        {/* PLAYER CONTROLS */}
                        <div className={`player-controls-bar ${turn === 'human' && (canRoll || dice.length > 0) ? 'active-turn' : ''}`}>
                            <div className="player-info">
                                <div className="player-avatar" style={{
                                    background: playerColor === PLAYER_AI
                                        ? 'radial-gradient(circle at 30% 30%, #4a4a4a, #000000)' // I am Red (Black/Red styling)
                                        : 'radial-gradient(circle at 30% 30%, #ffffff, #dcdcdc)', // I am White
                                    borderColor: playerColor === PLAYER_AI ? '#000' : '#b0b0b0'
                                }}>
                                    {userProfile.avatar && <img src={userProfile.avatar} style={{ width: '100%', height: '100%', borderRadius: '50%', objectFit: 'cover' }} />}
                                </div>
                                <div className="player-name">
                                    <div style={{ fontWeight: 'bold' }}>
                                        {wallet ? (wallet.startsWith('Guest') ? 'Guest' : (userProfile.name || `${wallet.slice(0, 4)}...${wallet.slice(-4)}`)) : 'Player 1'}
                                    </div>
                                    {wallet && !wallet.startsWith('Guest') && userProfile.stats && (
                                        <div style={{ fontSize: '0.8rem', color: '#aaa', marginTop: '2px', display: 'flex', alignItems: 'center', gap: '6px' }}>
                                            {userProfile.name && (
                                                <>
                                                    <span style={{ fontFamily: 'monospace', color: '#8d6e63' }}>
                                                        {wallet.slice(0, 4)}...{wallet.slice(-4)}
                                                    </span>
                                                    <span></span>
                                                </>
                                            )}
                                            <span>Lvl {userProfile.stats.level}</span>
                                            <span></span>
                                            <span>{userProfile.stats.wins}W / {userProfile.stats.losses}L</span>
                                        </div>
                                    )}
                                </div>
                            </div>

                            <div className="controls-actions">
                                <button
                                    className="btn-action"
                                    onClick={handleUndo}
                                    disabled={turn !== 'human' || history.length === 0 || finishingTurn || dice.length === 0}
                                >
                                    Undo
                                </button>
                                {validMoves.includes(-1) ? (
                                    <button
                                        className="btn-action"
                                        style={{ backgroundColor: '#ffca28', color: '#000', fontWeight: 'bold' }}
                                        onClick={() => handlePointClick(-1)}
                                    >
                                        BEAR OFF
                                    </button>
                                ) : (
                                    <button
                                        className="btn-action"
                                        onClick={() => isBlocked ? handlePassTurn() : handleManualRoll()}
                                        disabled={(!canRoll && !isBlocked) || turn !== 'human'}
                                        style={(dice.length > 0 && turn === 'human') ? { background: isBlocked ? '#d32f2f' : '#2e7d32', color: '#fff', border: isBlocked ? '1px solid #b71c1c' : '1px solid #66bb6a', cursor: 'pointer' } : {}}
                                    >
                                        {isBlocked ? "Pass Turn (Blocked)" : ((dice.length > 0 && turn === 'human') ? "Make Your Moves" : "Roll Dice")}
                                    </button>
                                )}
                            </div>
                        </div>

                        {/* CHAT REMOVED FROM HERE */}
                    </div>

                    {/* RIGHT SIDEBAR REMOVED */}
                </div>
            );
        }

        function Point({ index, data, isTop, selected, isValid, onClick, playerColor }) {
            const checkers = [];
            for (let i = 0; i < data.count; i++) {
                // FIXED: Absolute colors. Player 1 (Human) = White. Player 2 (AI/Opponent) = Red.
                checkers.push(<div key={i} className={`checker ${data.player === 1 ? 'white' : 'red'}`}></div>);
            }
            // Color logic: even index is light? Standard board pattern alternating.
            const isDark = index % 2 !== 0;

            return (
                <div
                    className={`point ${isTop ? 'down' : 'up'} ${isDark ? 'dark' : 'light'} ${selected ? 'selected' : ''} ${isValid ? 'valid' : ''}`}
                    onClick={onClick}
                >
                    <div className="point-triangle"></div>
                    <div className="checker-stack">
                        {checkers}
                    </div>
                    {/* Debug Index */}
                    {/* <div className="index-label">{index}</div> */}
                </div>
            );
        }

        function OffTray({ player, count, position, valid, onClick }) {
            const isHuman = player === PLAYER_HUMAN;

            // Create array for visual pieces, capped if needed to prevent rendering issues, 
            // though 15 checks fit easily.
            const pieces = Array.from({ length: count });

            return (
                <div
                    className={`off-tray ${position} ${valid ? 'valid' : ''}`}
                    onClick={valid ? onClick : undefined}
                >
                    <div className="off-tray-label">OFF</div>
                    <div className="off-pieces-row">
                        {pieces.map((_, i) => (
                            <div key={i} className={`off-piece ${isHuman ? 'white' : 'red'}`} style={{ zIndex: i }}></div>
                        ))}
                    </div>
                    {count > 0 && <div className="off-counter-text">{count}</div>}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>